{"ast":null,"code":"import _defineProperty from \"/Users/freethinking/Desktop/codecademy/PetPhysique_Pro/alx-react/0x09-react_redux_connectors_and_providers/task_3/dashboard/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nimport _glob from 'glob-to-regexp';\nimport pathToRegexp from 'path-to-regexp';\nimport querystring from 'querystring';\nimport isSubset from 'is-subset';\nimport isEqual from 'lodash.isequal';\nimport { headers as headerUtils, getPath, getQuery, normalizeUrl } from '../lib/request-utils.js';\nimport { debug } from '../lib/debug.js';\nvar debuggableUrlFunc = function debuggableUrlFunc(func) {\n  return function (url) {\n    debug('Actual url:', url);\n    return func(url);\n  };\n};\nvar stringMatchers = {\n  begin: function begin(targetString) {\n    return debuggableUrlFunc(function (url) {\n      return url.indexOf(targetString) === 0;\n    });\n  },\n  end: function end(targetString) {\n    return debuggableUrlFunc(function (url) {\n      return url.substr(-targetString.length) === targetString;\n    });\n  },\n  glob: function glob(targetString) {\n    var urlRX = _glob(targetString);\n    return debuggableUrlFunc(function (url) {\n      return urlRX.test(url);\n    });\n  },\n  express: function express(targetString) {\n    var urlRX = pathToRegexp(targetString);\n    return debuggableUrlFunc(function (url) {\n      return urlRX.test(getPath(url));\n    });\n  },\n  path: function path(targetString) {\n    return debuggableUrlFunc(function (url) {\n      return getPath(url) === targetString;\n    });\n  }\n};\nvar getHeaderMatcher = function getHeaderMatcher(_ref) {\n  var expectedHeaders = _ref.headers;\n  debug('Generating header matcher');\n  if (!expectedHeaders) {\n    debug('  No header expectations defined - skipping');\n    return;\n  }\n  var expectation = headerUtils.toLowerCase(expectedHeaders);\n  debug('  Expected headers:', expectation);\n  return function (url, _ref2) {\n    var _ref2$headers = _ref2.headers,\n      headers = _ref2$headers === void 0 ? {} : _ref2$headers;\n    debug('Attempting to match headers');\n    var lowerCaseHeaders = headerUtils.toLowerCase(headerUtils.normalize(headers));\n    debug('  Expected headers:', expectation);\n    debug('  Actual headers:', lowerCaseHeaders);\n    return Object.keys(expectation).every(function (headerName) {\n      return headerUtils.equal(lowerCaseHeaders[headerName], expectation[headerName]);\n    });\n  };\n};\nvar getMethodMatcher = function getMethodMatcher(_ref3) {\n  var expectedMethod = _ref3.method;\n  debug('Generating method matcher');\n  if (!expectedMethod) {\n    debug('  No method expectations defined - skipping');\n    return;\n  }\n  debug('  Expected method:', expectedMethod);\n  return function (url, _ref4) {\n    var method = _ref4.method;\n    debug('Attempting to match method');\n    var actualMethod = method ? method.toLowerCase() : 'get';\n    debug('  Expected method:', expectedMethod);\n    debug('  Actual method:', actualMethod);\n    return expectedMethod === actualMethod;\n  };\n};\nvar getQueryStringMatcher = function getQueryStringMatcher(_ref5) {\n  var passedQuery = _ref5.query;\n  debug('Generating query parameters matcher');\n  if (!passedQuery) {\n    debug('  No query parameters expectations defined - skipping');\n    return;\n  }\n  var expectedQuery = querystring.parse(querystring.stringify(passedQuery));\n  debug('  Expected query parameters:', passedQuery);\n  var keys = Object.keys(expectedQuery);\n  return function (url) {\n    debug('Attempting to match query parameters');\n    var query = querystring.parse(getQuery(url));\n    debug('  Expected query parameters:', expectedQuery);\n    debug('  Actual query parameters:', query);\n    return keys.every(function (key) {\n      if (Array.isArray(query[key])) {\n        if (!Array.isArray(expectedQuery[key])) {\n          return false;\n        }\n        return isEqual(query[key].sort(), expectedQuery[key].sort());\n      }\n      return query[key] === expectedQuery[key];\n    });\n  };\n};\nvar getParamsMatcher = function getParamsMatcher(_ref6) {\n  var expectedParams = _ref6.params,\n    matcherUrl = _ref6.url;\n  debug('Generating path parameters matcher');\n  if (!expectedParams) {\n    debug('  No path parameters expectations defined - skipping');\n    return;\n  }\n  if (!/express:/.test(matcherUrl)) {\n    throw new Error('fetch-mock: matching on params is only possible when using an express: matcher');\n  }\n  debug('  Expected path parameters:', expectedParams);\n  var expectedKeys = Object.keys(expectedParams);\n  var keys = [];\n  var re = pathToRegexp(matcherUrl.replace(/^express:/, ''), keys);\n  return function (url) {\n    debug('Attempting to match path parameters');\n    var vals = re.exec(getPath(url)) || [];\n    vals.shift();\n    var params = keys.reduce(function (map, _ref7, i) {\n      var name = _ref7.name;\n      return vals[i] ? Object.assign(map, _defineProperty({}, name, vals[i])) : map;\n    }, {});\n    debug('  Expected path parameters:', expectedParams);\n    debug('  Actual path parameters:', params);\n    return expectedKeys.every(function (key) {\n      return params[key] === expectedParams[key];\n    });\n  };\n};\nvar getBodyMatcher = function getBodyMatcher(route, fetchMock) {\n  var matchPartialBody = fetchMock.getOption('matchPartialBody', route);\n  var expectedBody = route.body;\n  debug('Generating body matcher');\n  return function (url, _ref8) {\n    var body = _ref8.body,\n      _ref8$method = _ref8.method,\n      method = _ref8$method === void 0 ? 'get' : _ref8$method;\n    debug('Attempting to match body');\n    if (method.toLowerCase() === 'get') {\n      debug('  GET request - skip matching body');\n      // GET requests don’t send a body so the body matcher should be ignored for them\n      return true;\n    }\n    var sentBody;\n    try {\n      debug('  Parsing request body as JSON');\n      sentBody = JSON.parse(body);\n    } catch (err) {\n      debug('  Failed to parse request body as JSON', err);\n    }\n    debug('Expected body:', expectedBody);\n    debug('Actual body:', sentBody);\n    if (matchPartialBody) {\n      debug('matchPartialBody is true - checking for partial match only');\n    }\n    return sentBody && (matchPartialBody ? isSubset(sentBody, expectedBody) : isEqual(sentBody, expectedBody));\n  };\n};\nvar getFullUrlMatcher = function getFullUrlMatcher(route, matcherUrl, query) {\n  // if none of the special syntaxes apply, it's just a simple string match\n  // but we have to be careful to normalize the url we check and the name\n  // of the route to allow for e.g. http://it.at.there being indistinguishable\n  // from http://it.at.there/ once we start generating Request/Url objects\n  debug('  Matching using full url', matcherUrl);\n  var expectedUrl = normalizeUrl(matcherUrl);\n  debug('  Normalised url to:', matcherUrl);\n  if (route.identifier === matcherUrl) {\n    debug('  Updating route identifier to match normalized url:', matcherUrl);\n    route.identifier = expectedUrl;\n  }\n  return function (matcherUrl) {\n    debug('Expected url:', expectedUrl);\n    debug('Actual url:', matcherUrl);\n    if (query && expectedUrl.indexOf('?')) {\n      debug('Ignoring query string when matching url');\n      return matcherUrl.indexOf(expectedUrl) === 0;\n    }\n    return normalizeUrl(matcherUrl) === expectedUrl;\n  };\n};\nvar getFunctionMatcher = function getFunctionMatcher(_ref9) {\n  var functionMatcher = _ref9.functionMatcher;\n  debug('Detected user defined function matcher', functionMatcher);\n  return function () {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n    debug('Calling function matcher with arguments', args);\n    return functionMatcher.apply(void 0, args);\n  };\n};\nvar getUrlMatcher = function getUrlMatcher(route) {\n  debug('Generating url matcher');\n  var matcherUrl = route.url,\n    query = route.query;\n  if (matcherUrl === '*') {\n    debug('  Using universal * rule to match any url');\n    return function () {\n      return true;\n    };\n  }\n  if (matcherUrl instanceof RegExp) {\n    debug('  Using regular expression to match url:', matcherUrl);\n    return function (url) {\n      return matcherUrl.test(url);\n    };\n  }\n  if (matcherUrl.href) {\n    debug('  Using URL object to match url', matcherUrl);\n    return getFullUrlMatcher(route, matcherUrl.href, query);\n  }\n  for (var shorthand in stringMatchers) {\n    if (matcherUrl.indexOf(\"\".concat(shorthand, \":\")) === 0) {\n      debug(\"  Using \".concat(shorthand, \": pattern to match url\"), matcherUrl);\n      var urlFragment = matcherUrl.replace(new RegExp(\"^\".concat(shorthand, \":\")), '');\n      return stringMatchers[shorthand](urlFragment);\n    }\n  }\n  return getFullUrlMatcher(route, matcherUrl, query);\n};\nexport default [{\n  name: 'query',\n  matcher: getQueryStringMatcher\n}, {\n  name: 'method',\n  matcher: getMethodMatcher\n}, {\n  name: 'headers',\n  matcher: getHeaderMatcher\n}, {\n  name: 'params',\n  matcher: getParamsMatcher\n}, {\n  name: 'body',\n  matcher: getBodyMatcher,\n  usesBody: true\n}, {\n  name: 'functionMatcher',\n  matcher: getFunctionMatcher\n}, {\n  name: 'url',\n  matcher: getUrlMatcher\n}];","map":{"version":3,"names":["glob","pathToRegexp","querystring","isSubset","isEqual","headers","headerUtils","getPath","getQuery","normalizeUrl","debug","debuggableUrlFunc","func","url","stringMatchers","begin","targetString","indexOf","end","substr","length","urlRX","test","express","path","getHeaderMatcher","_ref","expectedHeaders","expectation","toLowerCase","_ref2","_ref2$headers","lowerCaseHeaders","normalize","Object","keys","every","headerName","equal","getMethodMatcher","_ref3","expectedMethod","method","_ref4","actualMethod","getQueryStringMatcher","_ref5","passedQuery","query","expectedQuery","parse","stringify","key","Array","isArray","sort","getParamsMatcher","_ref6","expectedParams","params","matcherUrl","Error","expectedKeys","re","replace","vals","exec","shift","reduce","map","_ref7","i","name","assign","_defineProperty","getBodyMatcher","route","fetchMock","matchPartialBody","getOption","expectedBody","body","_ref8","_ref8$method","sentBody","JSON","err","getFullUrlMatcher","expectedUrl","identifier","getFunctionMatcher","_ref9","functionMatcher","_len","arguments","args","_key","apply","getUrlMatcher","RegExp","href","shorthand","concat","urlFragment","matcher","usesBody"],"sources":["/Users/freethinking/Desktop/codecademy/PetPhysique_Pro/alx-react/0x09-react_redux_connectors_and_providers/task_3/dashboard/node_modules/fetch-mock/src/Route/matchers.js"],"sourcesContent":["import glob from 'glob-to-regexp';\nimport pathToRegexp from 'path-to-regexp';\nimport querystring from 'querystring';\nimport isSubset from 'is-subset';\nimport isEqual from 'lodash.isequal';\nimport {\n\theaders as headerUtils,\n\tgetPath,\n\tgetQuery,\n\tnormalizeUrl,\n} from '../lib/request-utils.js';\nimport { debug } from '../lib/debug.js';\n\nconst debuggableUrlFunc = (func) => (url) => {\n\tdebug('Actual url:', url);\n\treturn func(url);\n};\n\nconst stringMatchers = {\n\tbegin: (targetString) =>\n\t\tdebuggableUrlFunc((url) => url.indexOf(targetString) === 0),\n\tend: (targetString) =>\n\t\tdebuggableUrlFunc(\n\t\t\t(url) => url.substr(-targetString.length) === targetString,\n\t\t),\n\tglob: (targetString) => {\n\t\tconst urlRX = glob(targetString);\n\t\treturn debuggableUrlFunc((url) => urlRX.test(url));\n\t},\n\texpress: (targetString) => {\n\t\tconst urlRX = pathToRegexp(targetString);\n\t\treturn debuggableUrlFunc((url) => urlRX.test(getPath(url)));\n\t},\n\tpath: (targetString) =>\n\t\tdebuggableUrlFunc((url) => getPath(url) === targetString),\n};\n\nconst getHeaderMatcher = ({ headers: expectedHeaders }) => {\n\tdebug('Generating header matcher');\n\tif (!expectedHeaders) {\n\t\tdebug('  No header expectations defined - skipping');\n\t\treturn;\n\t}\n\tconst expectation = headerUtils.toLowerCase(expectedHeaders);\n\tdebug('  Expected headers:', expectation);\n\treturn (url, { headers = {} }) => {\n\t\tdebug('Attempting to match headers');\n\t\tconst lowerCaseHeaders = headerUtils.toLowerCase(\n\t\t\theaderUtils.normalize(headers),\n\t\t);\n\t\tdebug('  Expected headers:', expectation);\n\t\tdebug('  Actual headers:', lowerCaseHeaders);\n\t\treturn Object.keys(expectation).every((headerName) =>\n\t\t\theaderUtils.equal(lowerCaseHeaders[headerName], expectation[headerName]),\n\t\t);\n\t};\n};\n\nconst getMethodMatcher = ({ method: expectedMethod }) => {\n\tdebug('Generating method matcher');\n\tif (!expectedMethod) {\n\t\tdebug('  No method expectations defined - skipping');\n\t\treturn;\n\t}\n\tdebug('  Expected method:', expectedMethod);\n\treturn (url, { method }) => {\n\t\tdebug('Attempting to match method');\n\t\tconst actualMethod = method ? method.toLowerCase() : 'get';\n\t\tdebug('  Expected method:', expectedMethod);\n\t\tdebug('  Actual method:', actualMethod);\n\t\treturn expectedMethod === actualMethod;\n\t};\n};\n\nconst getQueryStringMatcher = ({ query: passedQuery }) => {\n\tdebug('Generating query parameters matcher');\n\tif (!passedQuery) {\n\t\tdebug('  No query parameters expectations defined - skipping');\n\t\treturn;\n\t}\n\tconst expectedQuery = querystring.parse(querystring.stringify(passedQuery));\n\tdebug('  Expected query parameters:', passedQuery);\n\tconst keys = Object.keys(expectedQuery);\n\treturn (url) => {\n\t\tdebug('Attempting to match query parameters');\n\t\tconst query = querystring.parse(getQuery(url));\n\t\tdebug('  Expected query parameters:', expectedQuery);\n\t\tdebug('  Actual query parameters:', query);\n\t\treturn keys.every((key) => {\n\t\t\tif (Array.isArray(query[key])) {\n\t\t\t\tif (!Array.isArray(expectedQuery[key])) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\treturn isEqual(query[key].sort(), expectedQuery[key].sort());\n\t\t\t}\n\t\t\treturn query[key] === expectedQuery[key];\n\t\t});\n\t};\n};\n\nconst getParamsMatcher = ({ params: expectedParams, url: matcherUrl }) => {\n\tdebug('Generating path parameters matcher');\n\tif (!expectedParams) {\n\t\tdebug('  No path parameters expectations defined - skipping');\n\t\treturn;\n\t}\n\tif (!/express:/.test(matcherUrl)) {\n\t\tthrow new Error(\n\t\t\t'fetch-mock: matching on params is only possible when using an express: matcher',\n\t\t);\n\t}\n\tdebug('  Expected path parameters:', expectedParams);\n\tconst expectedKeys = Object.keys(expectedParams);\n\tconst keys = [];\n\tconst re = pathToRegexp(matcherUrl.replace(/^express:/, ''), keys);\n\treturn (url) => {\n\t\tdebug('Attempting to match path parameters');\n\t\tconst vals = re.exec(getPath(url)) || [];\n\t\tvals.shift();\n\t\tconst params = keys.reduce(\n\t\t\t(map, { name }, i) =>\n\t\t\t\tvals[i] ? Object.assign(map, { [name]: vals[i] }) : map,\n\t\t\t{},\n\t\t);\n\t\tdebug('  Expected path parameters:', expectedParams);\n\t\tdebug('  Actual path parameters:', params);\n\t\treturn expectedKeys.every((key) => params[key] === expectedParams[key]);\n\t};\n};\n\nconst getBodyMatcher = (route, fetchMock) => {\n\tconst matchPartialBody = fetchMock.getOption('matchPartialBody', route);\n\tconst { body: expectedBody } = route;\n\n\tdebug('Generating body matcher');\n\treturn (url, { body, method = 'get' }) => {\n\t\tdebug('Attempting to match body');\n\t\tif (method.toLowerCase() === 'get') {\n\t\t\tdebug('  GET request - skip matching body');\n\t\t\t// GET requests don’t send a body so the body matcher should be ignored for them\n\t\t\treturn true;\n\t\t}\n\n\t\tlet sentBody;\n\n\t\ttry {\n\t\t\tdebug('  Parsing request body as JSON');\n\t\t\tsentBody = JSON.parse(body);\n\t\t} catch (err) {\n\t\t\tdebug('  Failed to parse request body as JSON', err);\n\t\t}\n\t\tdebug('Expected body:', expectedBody);\n\t\tdebug('Actual body:', sentBody);\n\t\tif (matchPartialBody) {\n\t\t\tdebug('matchPartialBody is true - checking for partial match only');\n\t\t}\n\n\t\treturn (\n\t\t\tsentBody &&\n\t\t\t(matchPartialBody\n\t\t\t\t? isSubset(sentBody, expectedBody)\n\t\t\t\t: isEqual(sentBody, expectedBody))\n\t\t);\n\t};\n};\n\nconst getFullUrlMatcher = (route, matcherUrl, query) => {\n\t// if none of the special syntaxes apply, it's just a simple string match\n\t// but we have to be careful to normalize the url we check and the name\n\t// of the route to allow for e.g. http://it.at.there being indistinguishable\n\t// from http://it.at.there/ once we start generating Request/Url objects\n\tdebug('  Matching using full url', matcherUrl);\n\tconst expectedUrl = normalizeUrl(matcherUrl);\n\tdebug('  Normalised url to:', matcherUrl);\n\tif (route.identifier === matcherUrl) {\n\t\tdebug('  Updating route identifier to match normalized url:', matcherUrl);\n\t\troute.identifier = expectedUrl;\n\t}\n\n\treturn (matcherUrl) => {\n\t\tdebug('Expected url:', expectedUrl);\n\t\tdebug('Actual url:', matcherUrl);\n\t\tif (query && expectedUrl.indexOf('?')) {\n\t\t\tdebug('Ignoring query string when matching url');\n\t\t\treturn matcherUrl.indexOf(expectedUrl) === 0;\n\t\t}\n\t\treturn normalizeUrl(matcherUrl) === expectedUrl;\n\t};\n};\n\nconst getFunctionMatcher = ({ functionMatcher }) => {\n\tdebug('Detected user defined function matcher', functionMatcher);\n\treturn (...args) => {\n\t\tdebug('Calling function matcher with arguments', args);\n\t\treturn functionMatcher(...args);\n\t};\n};\n\nconst getUrlMatcher = (route) => {\n\tdebug('Generating url matcher');\n\tconst { url: matcherUrl, query } = route;\n\n\tif (matcherUrl === '*') {\n\t\tdebug('  Using universal * rule to match any url');\n\t\treturn () => true;\n\t}\n\n\tif (matcherUrl instanceof RegExp) {\n\t\tdebug('  Using regular expression to match url:', matcherUrl);\n\t\treturn (url) => matcherUrl.test(url);\n\t}\n\n\tif (matcherUrl.href) {\n\t\tdebug('  Using URL object to match url', matcherUrl);\n\t\treturn getFullUrlMatcher(route, matcherUrl.href, query);\n\t}\n\n\tfor (const shorthand in stringMatchers) {\n\t\tif (matcherUrl.indexOf(`${shorthand}:`) === 0) {\n\t\t\tdebug(`  Using ${shorthand}: pattern to match url`, matcherUrl);\n\t\t\tconst urlFragment = matcherUrl.replace(new RegExp(`^${shorthand}:`), '');\n\t\t\treturn stringMatchers[shorthand](urlFragment);\n\t\t}\n\t}\n\n\treturn getFullUrlMatcher(route, matcherUrl, query);\n};\n\nexport default [\n\t{ name: 'query', matcher: getQueryStringMatcher },\n\t{ name: 'method', matcher: getMethodMatcher },\n\t{ name: 'headers', matcher: getHeaderMatcher },\n\t{ name: 'params', matcher: getParamsMatcher },\n\t{ name: 'body', matcher: getBodyMatcher, usesBody: true },\n\t{ name: 'functionMatcher', matcher: getFunctionMatcher },\n\t{ name: 'url', matcher: getUrlMatcher },\n];\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}